package net.electroland.kioskengine  {		public class ButtonListItem extends Item{		private var buttonList:Array = new Array();				/*				BUTTONLISTITEM.as		by Aaron Siegel, 7-5-09				*/				public function ButtonListItem(conductor:Conductor, itemElement:XML){			super(conductor);			parseXML(itemElement);		}				public function itemEventHandler(event:ItemEvent):void{			// log the option picked and then follow the action/link of the button list			trace(event.getAction()+" "+event.getArguments());			if(itemEntries.hasOwnProperty("all")){				dispatchEvent(new ItemEvent(itemEntries["all"].action, itemEntries["all"].link));			} else {				dispatchEvent(new ItemEvent(itemEntries[conductor.getLanguage()].action, itemEntries[conductor.getLanguage()].link));			}		}				public function loadContent():void{			// nothing to do?		}				override protected function parseXML(itemElement:XML):void{			setID(itemElement.attribute("ID"));			setName(itemElement.attribute("Name"));			setType(itemElement.attribute("Type"));			setDescription(itemElement.attribute("Description"));			setLayer(Number(itemElement.attribute("Layer")));			x = Number(itemElement.attribute("x"));				// x/y/width/height never used here			y = Number(itemElement.attribute("y"));			setWidth(Number(itemElement.attribute("width")));			setHeight(Number(itemElement.attribute("height")));			for each (var itemEventElement:XML in itemElement.ItemEvent){				//trace(itemEventElement.attribute("Action"));				parseEffects(itemEventElement);			}			for each (var nestedItemElement:XML in itemElement.Item){				//trace(nestedItemElement);				var button:ButtonItem = new ButtonItem(conductor, nestedItemElement);				buttonList.push(button);			}			for each (var itemEntryElement:XML in itemElement.ItemEntry){				parseItemEntries(itemEntryElement);			}		}				override public function reset():void{			// buttons have independent timers			for each (var button in buttonList){				removeChild(button);				button.reset();				button.removeEventListener(ItemEvent.ITEM_EVENT, itemEventHandler);			}			super.reset();		}				public function startTimer():void{			// buttons have independent timers			for each (var button in buttonList){				addChild(button);				button.loadContent();				button.startTimer();				button.addEventListener(ItemEvent.ITEM_EVENT, itemEventHandler);			}			startEffectTimers();		}			}	}