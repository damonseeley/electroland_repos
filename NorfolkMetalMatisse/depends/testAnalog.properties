#global settings
settings.global = $pollrate 30 $suspect -1

# type definition
#  in this case, phoenix
#  this kind of device always has the extra values startRef and count.
#  * startRef is the starting register for data to be read from
#  * count is the number of registers to read starting from startRef.

# concrete instances of Phoenix bus coupler
iodevice.phoenix1 = $factory net.electroland.eio.devices.ModBusTCPSlaveDeviceFactory $ipaddress 192.168.247.21 $startRef 192 $count 4

# The output of each of this is simply Byte, Short, Integer, and Boolean.
#  it could suffice simply to save the Byte, Short, Integer, or Boolean to a Map (key = ichannel ID).
#  a separate hidden table can then store the actual IChannel.  See below.
# what are tags good for in this scenario?
ichannel.0 = $device phoenix1 $register 0 $datatype BYTES $endianness BIG $index 0 $tags i1 $x 623.18 $y 11.94 $z 0 $units meterPixels $class $filters boxcar
ichannel.1 = $device phoenix1 $register 0 $datatype BYTES $endianness BIG $index 1 $tags i1 $x 623.18 $y 11.94 $z 0 $units meterPixels $class $filters boxcar
ichannel.2 = $device phoenix1 $register 1 $datatype SHORT $endianness BIG          $tags i1 $x 623.18 $y 11.94 $z 0 $units meterPixels $class $filters boxcar
ichannel.3 = $device phoenix1 $register 2 $datatype INT   $endianness BIG          $tags i1 $x 623.18 $y 11.94 $z 0 $units meterPixels $class $filters doff,boxcar
ichannel.4 = $device phoenix1 $register 3 $datatype BIT   $endianness BIG $index 0 $tags i1 $x 623.18 $y 11.94 $z 0 $units meterPixels $class $filters doff
ichannel.5 = $device phoenix1 $register 3 $datatype BIT   $endianness BIG $index 1 $tags i1 $x 623.18 $y 11.94 $z 0 $units meterPixels $class $filters doff
ichannel.6 = $device phoenix1 $register 3 $datatype BIT   $endianness BIG $index 2 $tags i1 $x 623.18 $y 11.94 $z 0 $units meterPixels $class $filters doff
ichannel.7 = $device phoenix1 $register 3 $datatype BIT   $endianness BIG $index 3 $tags i1 $x 623.18 $y 11.94 $z 0 $units meterPixels $class $filters doff

iofilter.boxcar $class net.electroland.eio.filters.BoxcarFilter $samples 15
iofilter.doff $class net.electroland.eio.filters.DelayedOffFilter $millis 500
iofilter.toBool $class net.electroland.eio.filters.ConvertToBoolean $threshold 15000

abstract public class Channel {
    protected String id;
    protected List<IOFilter> = new ArrayList<IOFilter>();
    public Channel(ParameterMap map);
    public Object read(Array a); // <-- ?
}

public class ModBusTcpChannel {

    protected int register, int index;
    protected boolean isLittleEndian;
    protected int datatype;
    enum datatypes = {BIT, BYTE, SHORT, INT};

    public Channel(ParameterMap map){
        // setup the reader
    }
    public Object read(Array<InputRegister> registers){
        // returns Integer, Boolean, Shot, Byte as it has been directed
    }
}

Full set of objects:
===================
IOManager
IOChannel
IODeviceFactory
IODevice
IOFilter
ModBusTcpFactory
ModBusTcpDevice
ModBusTcpChannel