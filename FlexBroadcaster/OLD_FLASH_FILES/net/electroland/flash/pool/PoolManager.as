package net.electroland.flash.pool{	import flash.events.*;	import flash.display.*;	import flash.utils.*;	import flash.net.XMLSocket;	import net.electroland.flash.pool.*;	import net.electroland.flash.pool.creatures.*;	public class PoolManager extends MovieClip {		/*  LEFT TO DO:		-- z ordering (move fish up or down if it changed) --		-- tell the fish it's speed & depth per frame for depth animation --		-- better exception handling --		-- connection robustness --		*/		// from http://www.kirupa.com/forum/showthread.php?t=264505 :		//   String(LoaderInfo(root.loaderInfo).parameters["s0"]		var env:Environment;		var bg:Sprite;		var school:Array = new Array();		var host:String = (root.loaderInfo.parameters.server) ? root.loaderInfo.parameters.server : "192.168.2.60";		var port:int = (root.loaderInfo.parameters.port) ?  int(root.loaderInfo.parameters.port) : 1024;		var originx:int = 1024;//root.loaderInfo.parameters.originx;		var originy:int = 768;//root.loaderInfo.parameters.originy;		var clipwidth:int = stage.stageWidth;		var clipheight:int = stage.stageHeight;		var fps:Number = 0;		public function PoolManager() {			trace("FishBroadcastListener(): ");			trace("connect to broadcasts from " + host + ":" + port);			trace("stage origin: " + originx + ", " +originy );			trace("stage dimensions: " + stage.stageWidth + ", " + stage.stageHeight);			// get stage framerate for the html			if (root.loaderInfo.parameters.framerate) {				fps = new Number(root.loaderInfo.parameters.framerate);			}			// default frame rate is 60.			stage.frameRate = fps == 0 ? 60 : fps;			trace("fps=" + stage.frameRate);			// get stage quality from html			if (root.loaderInfo.parameters.quality) {				switch ( root.loaderInfo.parameters.quality ) {					case (StageQuality.LOW) :						stage.quality = StageQuality.LOW;						break;					case (StageQuality.MEDIUM) :						stage.quality = StageQuality.MEDIUM;						break;					case (StageQuality.HIGH) :						stage.quality = StageQuality.HIGH;						break;					case (StageQuality.BEST) :						stage.quality = StageQuality.BEST;						break;					default :						stage.quality = StageQuality.BEST;						break;				}			} else {				stage.quality = StageQuality.BEST;			}			trace("quality=" + stage.quality);			// connect.  The FlexBroadcast server requires this and ONLY this to establish the			// connection.  From this point on, the client will be receiving anything the			// broadcaster has to say via the onData() method.			var xmlsock:XMLSocket = new XMLSocket();			xmlsock.connect(host, port);			// subscribe to all events that come out of the socket listener			xmlsock.addEventListener(DataEvent.DATA, onDataCallback);			xmlsock.addEventListener(Event.CONNECT, this.onConnect);			xmlsock.addEventListener(Event.CLOSE, this.onClose);			xmlsock.addEventListener(IOErrorEvent.IO_ERROR, this.onIOError);			xmlsock.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onSecEvent);			// invisible background for boundry checks.			bg = new Sprite();			// we've pot a 100 pixel boundary around the background because fish bounding boxes			// don't actually encapsulate the fish (they are drawn with their heads at the origin.			bg.graphics.drawRect(-100, -100, clipwidth + 200, clipheight +200);			addChild(bg);			env  = new Environment("net/electroland/flash/pool/media/", 0, width, height);			// every time an XML packet arrives.		}		private function onDataCallback(event:DataEvent):void {			env.synch++;			// -load the xml			var myXML:XML = new XML(event.data);			for each (var property:XML in myXML.fish) {				// -for each fish, determine if the fish is already loaded.				var dispFish:DisplayObject = getChildByName(property.@id);				//   no?				if (!dispFish) {					var newFish:PoolCreature = null;					switch (int(property.@t)) {						case 0:							newFish = new PoolCreature(new BigFish1());							break;						case 1:							newFish = new PoolCreature(new MediumFish1());							break;						case 2:							newFish = new PoolCreature(new MediumFish2());							break;						case 3:							newFish = new PoolCreature(new MediumFish3());							break;						case 4:							newFish = new PoolCreature(new SmallFish1());							break;						case 5:							newFish = new PoolCreature(new SmallFish2());							break;						default:							// for now, no such thing as a default fish.							break;					}					// if we had a valid case above, add it to the scene					if (newFish) {						school[property.@id] = newFish;						dispFish = newFish.creature.init(env);						addChild(dispFish);					}				}				// dispFish would be null if the type didn't match anything in the switch case ave.				if (dispFish) {					// "kill" was requested					if (school[property.@id].getState() == -1) {						school[property.@id] == null;// remove from our list						removeChild(property.@id);// remove from the stage					} else {						//   update the fishes stage values						dispFish.name = property.@id;						dispFish.x = property.@x - originx;// adjust for frame						dispFish.y = property.@y - originy;// adjust for frame						dispFish.scaleX = property.@p;						dispFish.scaleY = property.@p;						dispFish.rotation = property.@o;						// if state has changed, notify the fish						if (school[property.@id].getState() != property.@s) {							school[property.@id].setState(property.@s);						}						// if accent has change, notify the fish						if (school[property.@id].getAccent() != property.@a) {							school[property.@id].setAccent(property.@a);						}						// if there is a movie request, pass it to the fish						if (property.@m && String(property.@m).length > 0) {							school[property.@id].creature.activateVideo("video/" + property.@m);						}						//   determine if the fish is on this scene (de)activate						if (bg.hitTestObject(dispFish)) {							dispFish.visible = true;						} else {							dispFish.visible = false;						}					}				}			}		}		private function onSecEvent(event:SecurityErrorEvent):void {			trace("onSecEvent: " + event);		}		private function onIOError(event:IOErrorEvent):void {			trace("onIOError: " + event);		}		private function onClose(event:Event):void {			trace("onClose: " + event);		}		private function onConnect(event:Event):void {			trace("onConnect: " + event);		}	}}