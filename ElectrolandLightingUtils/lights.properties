# The system frame rate. If this is not specified, the default is 30.
fps = 30

# These three properties should be used sparingly,  They are really for tuning
# the system if you accidentally spec'd the rasters and detectors to dimensions
# that turn out to be too big for your desired performance.

# Scales the positions of each detector. Default is 1.0 when not specified.
detectorPositionScaling = 1.0

# Scales the dimensions of each detector. Default is 1.0 when not specified.
detectorDimensionScaling = 1.0

# Scales the dimensions of each raster. Default is 1.0 when not specified.
rasterDimensionScaling = 1.0

# The following objects define the relationships between detectors and the
# packets to be generated.  There are primarily three objects: rasters, 
# recipients, and detectors.  
# A raster is really just a "preferred" size for any given recipient.  E.g., 
# it's the size raster you should generate if you want to sync with this raster 
# for best results.  Ideally, you want to make sure whatever raster size you set 
# is large enough to bound all the detectors bound to your recipient.
#
# A recipient represents a single receiever on the network of a packet of data.
# Each recipient has a set number of channels, with each channel (presumably)
# tied to a detector.
#
# A detector is an area on a raster encompassing some pixels. When you call
# sync on a recipient, the detector will grab all the pixels from the Raster
# object it was passed, transform all of the pixels into a single byte value, 
# and then plug that value into the channel specified by that recipient.
#
# The relationship between recipients and detectors is this: Any detector has
# to be "plugged" into a channel in a detector. You can do this one of two ways.
# Either you can use patch groups, or you can use patch objects.  Patch
# objects are more granular.  When you specify a channel object, you simply
# state which detector is tied to which recipient, and on what channel.  Patch
# groups enable you to short cut this process if it is a common pattern, 
# repeated.  In order to use a patch group, each detector in the group MUST
# be plugged into the exact same channel for each recipient that is a member
# of the group.
#
# So, when it comes time implement this, assume a process like this:
# 1.) generate a DetectorManager
# 2.) ask the detector manager for the list of recipients
# 3.) any time you want to sync a recipient, use getPreferredDimensions() in the
#	  recipient object to determine how large a raster to generate.
# 4.) instantiate your raster
# 5.) draw on the raster
# 6.) sync the raster to the recipient as appropriate.
# As you can be syncing to multiple recipients simultaneously, you may want to
# sanity check that all of those recipients have the same preferredDimensions.

# Rasters
#	raster.id = -width int -height int
# examples:
raster.myRaster = -width 100 -height 100
raster.myOtherRaster = -width 100 -height 50

# ByteMap
#   bytemap.id = -fullmap [byte0,byte1,byte2...byte255] (tabs, spaces, commas re acceptable delimiters)
# example:
bytemap.myFullMap = [0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15\
					16	17	18	19	20	21	22	23	24	25	26	27	28	29	30	31\
					32	33	34	35	36	37	38	39	40	41	42	43	44	45	46	47\
					48	49	50	51	52	53	54	55	56	57	58	59	60	61	62	63\
					64	65	66	67	68	69	70	71	72	73	74	75	76	77	78	79\
					80	81	82	83	84	85	86	87	88	89	90	91	92	93	94	95\
					96	97	98	99	100	101	102	103	104	105	106	107	108	109	110	111\
					112	113	114	115	116	117	118	119	120	121	122	123	124	125	126	127\
					128	129	130	131	132	133	134	135	136	137	138	139	140	141	142	143\
					144	145	146	147	148	149	150	151	152	153	154	155	156	157	158	159\
					160	161	162	163	164	165	166	167	168	169	170	171	172	173	174	175\
					176	177	178	179	180	181	182	183	184	185	186	187	188	189	190	191\
					192	193	194	195	196	197	198	199	200	201	202	203	204	205	206	207\
					208	209	210	211	212	213	214	215	216	217	218	219	220	221	222	223\
					224	225	226	227	228	229	230	231	232	233	234	235	236	237	238	239\
					240	241	242	243	244	245	246	247	248	249	250	251	252	253	254	255]

# (x,y) where x = the linear value and y = the mapping.  (0,0) and (255,255) are assumed ALWAYS
# to be on the curve.
# THIS IS NOT SUPPORTED YET.
bytemap.my9PointCurveMap = [(31,31), (63,63), (95,95), (127,127), (159,159), (191,191), (223,223)]

# the example below depresses the middle of the curve a little.
# THIS IS NOT SUPPORTED YET.
bytemap.my1PointCurveMap = [(127,100)]

# Recipients
#	recipient.id = -protocol ARTNET -channels int -address string -universe int -defaultRaster raster.id [-patchgroup string]
#	recipient.id = -protocol HALEUDP -channels int -address string -port int -defaultRaster raster.id [-patchgroup string]
# examples:
recipient.wall = -protocol ARTNET -channels 100 -address 127.0.0.1 -universe 1 -patchgroup group1 -defaultRaster myRaster
recipient.wall2 = -protocol ARTNET -channels 50 -address 127.0.0.1 -universe 2 -defaultRaster myRaster
recipient.floor = -protocol HALEUDP -channels 120 -address 127.0.0.2 -port 100 -patchgroup group1 -defaultRaster myOtherRaster
recipient.tv = -protocol FLEXXML -channels 120 -port 8001 -defaultRaster myRaster -patchgroup group1


# Detectors
#	detector.id = -boundary boundaryObject -model modelClasspath [-patchgroup string int]
# note: if you use specify a patch group you MUST include both the patchgroup name AND the channel. 
# note2: we currently only recognize one type of boundary object: rectangle(x,y,width,height). x,y is relative to origin = top left.
# examples:
detector.d1 = -boundary rectangle(0,0,100,100) -model net.electroland.lighting.detector.models.RedDetectionModel -patchgroup group1 0
detector.d2 = -boundary rectangle(10,10,100,100) -model net.electroland.lighting.detector.models.ThresholdDetectionModel

# Patches
#	patch.id = -channel [channel] -recipient [recipient.id] -detector [detector.id]
# examples:
patch.0 = -channel 0 -recipient wall2 -detector d1
patch.1 = -channel 1 -recipient wall2 -detector d2
