# The system frame rate. If this is not specified, the default is 30.
fps = 30

# These three properties should be used sparingly,  They are really for tuning
# the system if you accidentally spec'd the rasters and detectors to dimensions
# that turn out to be too big for your desired performance.

# Scales the positions of each detector. Default is 1.0 when not specified.
detectorPositionScaling = 1.0

# Scales the dimensions of each detector. Default is 1.0 when not specified.
detectorDimensionScaling = 1.0

# Scales the dimensions of each raster. Default is 1.0 when not specified.
rasterDimensionScaling = 1.0

# The following objects define the relationships between detectors and the
# packets to be generated.  There are primarily three objects: rasters, 
# recipients, and detectors.  
# A raster is really just a "preferred" size for any given recipient.  E.g., 
# it's the size raster you should generate if you want to sync with this raster 
# for best results.  Ideally, you want to make sure whatever raster size you set 
# is large enough to bound all the detectors bound to your recipient.
#
# A recipient represents a single receiever on the network of a packet of data.
# Each recipient has a set number of channels, with each channel (presumably)
# tied to a detector.
#
# A detector is an area on a raster encompassing some pixels. When you call
# sync on a recipient, the detector will grab all the pixels from the Raster
# object it was passed, transform all of the pixels into a single byte value, 
# and then plug that value into the channel specified by that recipient.
#
# The relationship between recipients and detectors is this: Any detector has
# to be "plugged" into a channel in a detector. You can do this one of two ways.
# Either you can use patch groups, or you can use patch objects.  Patch
# objects are more granular.  When you specify a channel object, you simply
# state which detector is tied to which recipient, and on what channel.  Patch
# groups enable you to short cut this process if it is a common pattern, 
# repeated.  In order to use a patch group, each detector in the group MUST
# be plugged into the exact same channel for each recipient that is a member
# of the group.
#
# So, when it comes time implement this, assume a process like this:
# 1.) generate a DetectorManager
# 2.) ask the detector manager for the list of recipients
# 3.) any time you want to sync a recipient, use getPreferredDimensions() in the
#	  recipient object to determine how large a raster to generate.
# 4.) instantiate your raster
# 5.) draw on the raster
# 6.) sync the raster to the recipient as appropriate.
# As you can be syncing to multiple recipients simultaneously, you may want to
# sanity check that all of those recipients have the same preferredDimensions.

# Rasters
#	raster.id = -width int -height int
# examples:
raster.myRaster = -width 100 -height 100
raster.myOtherRaster = -width 100 -height 50

# ByteMap
#   bytemap.id = -fullmap [byte0,byte1,byte2...byte255] (tabs, spaces, commas re acceptable delimiters)
# example (reverses all data):
bytemap.reverse = -fullmap [255,254,253,252,251,250,249,248,247,246,245,244,243,242,241,240,\
							239,238,237,236,235,234,233,232,231,230,229,228,227,226,225,224,\
							223,222,221,220,219,218,217,216,215,214,213,212,211,210,209,208,\
							207,206,205,204,203,202,201,200,199,198,197,196,195,194,193,192,\
							191,190,189,188,187,186,185,184,183,182,181,180,179,178,177,176,\
							175,174,173,172,171,170,169,168,167,166,165,164,163,162,161,160,\
							159,158,157,156,155,154,153,152,151,150,149,148,147,146,145,144,\
							143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,\
							127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,\
							111,110,109,108,107,106,105,104,103,102,101,100,99, 98, 97, 96,\
							95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80,\
							79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64,\
							63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48,\
							47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32,\
							31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,\
							15, 14, 13, 12, 11, 10, 9,  8,  7,  6,  5,  4,  3,  2,  1,  0]

# Recipients
#	recipient.id = -protocol ARTNET -channels int -address string -universe int -defaultRaster raster.id [-patchgroup string]
#	recipient.id = -protocol HALEUDP -channels int -address string -port int -defaultRaster raster.id [-patchgroup string]
# examples:
recipient.wall = -protocol ARTNET -channels 100 -address 127.0.0.1 -universe 1 -patchgroup group1 -defaultRaster myRaster
recipient.wall2 = -protocol ARTNET -channels 50 -address 127.0.0.1 -universe 2 -defaultRaster myRaster
recipient.floor = -protocol HALEUDP -channels 120 -address 127.0.0.2 -port 100 -patchgroup group1 -defaultRaster myOtherRaster
recipient.tv = -protocol FLEXXML -channels 120 -port 8001 -defaultRaster myRaster -patchgroup group1
recipient.withByteMap = -protocol FLEXXML -channels 120 -port 8001 -defaultRaster myRaster -patchgroup group1 -bytemap reverse


# Detectors
#	detector.id = -boundary boundaryObject -model modelClasspath [-patchgroup string int]
# note: if you use specify a patch group you MUST include both the patchgroup name AND the channel. 
# note2: we currently only recognize one type of boundary object: rectangle(x,y,width,height). x,y is relative to origin = top left.
# examples:
detector.d1 = -boundary rectangle(0,0,100,100) -model net.electroland.lighting.detector.models.RedDetectionModel -patchgroup group1 0
detector.d2 = -boundary rectangle(10,10,100,100) -model net.electroland.lighting.detector.models.ThresholdDetectionModel

# Patches
#	patch.id = -channel [channel] -recipient [recipient.id] -detector [detector.id]
# examples:
patch.0 = -channel 0 -recipient wall2 -detector d1
patch.1 = -channel 1 -recipient wall2 -detector d2
